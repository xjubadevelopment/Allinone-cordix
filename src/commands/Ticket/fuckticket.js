import {
  EmbedBuilder,
  AttachmentBuilder,
  PermissionFlagsBits,
} from "discord.js";
import { db } from "#database/DatabaseManager";
import emoji from "#config/emoji";

async function generateHTMLTranscript(channel, ticketData, panel, client) {
  const messages = await channel.messages.fetch({ limit: 100 });
  const sortedMessages = messages.sort((a, b) => a.createdTimestamp - b.createdTimestamp);

  const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ticket #${ticketData.ticket_id} Transcript - FORCE CLOSED</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: #36393f; color: #dcddde; padding: 20px; }
    .header { background: #ed4245; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .header h1 { color: #fff; font-size: 24px; margin-bottom: 10px; }
    .header p { color: #fff; font-size: 14px; }
    .warning { background: #fee75c; color: #000; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-weight: bold; }
    .messages { background: #36393f; }
    .message { display: flex; padding: 8px 16px; }
    .message:hover { background: #32353b; }
    .avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 16px; background: #5865f2; display: flex; align-items: center; justify-content: center; color: #fff; font-weight: bold; }
    .content { flex: 1; }
    .author { font-weight: 600; color: #fff; margin-right: 8px; }
    .timestamp { color: #72767d; font-size: 12px; }
    .text { margin-top: 4px; line-height: 1.4; word-wrap: break-word; }
    .attachment { margin-top: 8px; padding: 10px; background: #2f3136; border-radius: 4px; }
    .attachment a { color: #00aff4; text-decoration: none; }
    .footer { margin-top: 20px; padding: 20px; background: #2f3136; border-radius: 8px; text-align: center; color: #72767d; font-size: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>FORCE CLOSED - Ticket #${ticketData.ticket_id} - ${ticketData.category || "General"}</h1>
    <p>Created by User ID: ${ticketData.user_id}</p>
    <p>Transcript generated on ${new Date().toLocaleString()}</p>
  </div>
  <div class="warning">
    ⚠️ This ticket was force closed and the user was muted for 1 day due to misconduct.
  </div>
  <div class="messages">
    ${sortedMessages.map(msg => `
      <div class="message">
        <div class="avatar">${msg.author.username.charAt(0).toUpperCase()}</div>
        <div class="content">
          <span class="author">${msg.author.tag}</span>
          <span class="timestamp">${msg.createdAt.toLocaleString()}</span>
          <div class="text">${msg.content || ""}</div>
          ${msg.attachments.size > 0 ? `
            <div class="attachment">
              ${msg.attachments.map(att => `<a href="${att.url}" target="_blank">${att.name}</a>`).join("<br>")}
            </div>
          ` : ""}
        </div>
      </div>
    `).join("")}
  </div>
  <div class="footer">
    <p>Total Messages: ${sortedMessages.size}</p>
    <p>Generated by ${client.user.username} - FORCE CLOSED TICKET</p>
  </div>
</body>
</html>`;

  return html;
}

export default {
  name: "fuckticket",
  description: "Force close ticket, mute user for 1 day, and send transcript to owner/admin/creator",
  usage: "fuckticket [reason]",
  aliases: ["forceclose", "fticket"],
  category: "Ticket",
  cooldown: 5,

  async execute({ client, message, args }) {
    const ticketData = db.getTicket(message.channel.id);

    if (!ticketData) {
      const embed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} Not a Ticket`)
        .setDescription("This command can only be used in a ticket channel.");

      return message.reply({ embeds: [embed] });
    }

    const panel = db.getTicketPanel(message.guild.id, ticketData.panel_id);

    if (!panel) {
      const embed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} Panel Not Found`)
        .setDescription("The ticket panel configuration was not found.");

      return message.reply({ embeds: [embed] });
    }

    const hasPermission =
      message.member.permissions.has(PermissionFlagsBits.ManageChannels) ||
      message.member.permissions.has(PermissionFlagsBits.Administrator) ||
      panel.supportRoles.some((roleId) =>
        message.member.roles.cache.has(roleId)
      );

    if (!hasPermission) {
      const embed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} No Permission`)
        .setDescription("You don't have permission to force close tickets. Only admins and ticket handlers can use this command.");

      return message.reply({ embeds: [embed] });
    }

    const reason = args.join(" ") || "Misconduct in ticket - No reason provided";

    const loadingEmbed = new EmbedBuilder()
      .setColor(0xED4245)
      .setTitle(`${emoji.get("loading")} Force Closing Ticket...`)
      .setDescription("Muting user, generating transcript, and notifying parties...");

    const loadingMsg = await message.channel.send({ embeds: [loadingEmbed] });

    try {
      const html = await generateHTMLTranscript(message.channel, ticketData, panel, client);
      const buffer = Buffer.from(html, "utf-8");

      const ticketCreator = await message.guild.members.fetch(ticketData.user_id).catch(() => null);
      
      if (ticketCreator && ticketCreator.moderatable) {
        try {
          await ticketCreator.timeout(24 * 60 * 60 * 1000, reason);
        } catch (error) {
          console.error("Failed to mute user:", error);
        }
      }

      const forceCloseEmbed = new EmbedBuilder()
        .setColor(0xED4245)
        .setTitle(`⚠️ Ticket Force Closed`)
        .setDescription(
          `**Ticket:** #${ticketData.ticket_id}\n` +
          `**Category:** ${ticketData.category || "General"}\n` +
          `**Created By:** <@${ticketData.user_id}>\n` +
          `**Force Closed By:** ${message.author}\n` +
          `**Reason:** ${reason}\n` +
          `**Action:** User muted for 1 day\n` +
          `**Closed At:** <t:${Math.floor(Date.now() / 1000)}:F>`
        );

      const owner = await message.guild.fetchOwner().catch(() => null);
      if (owner) {
        try {
          const ownerAttachment = new AttachmentBuilder(Buffer.from(html, "utf-8"), {
            name: `ticket-${ticketData.ticket_id}-forceclose-transcript.html`,
          });
          await owner.send({
            embeds: [forceCloseEmbed],
            files: [ownerAttachment],
          });
        } catch (error) {
          console.log("Could not DM server owner");
        }
      }

      const admins = message.guild.members.cache.filter(member => 
        member.permissions.has(PermissionFlagsBits.Administrator) && 
        !member.user.bot &&
        member.id !== owner?.id
      );

      for (const [, admin] of admins) {
        try {
          const adminAttachment = new AttachmentBuilder(Buffer.from(html, "utf-8"), {
            name: `ticket-${ticketData.ticket_id}-forceclose-transcript.html`,
          });
          await admin.send({
            embeds: [forceCloseEmbed],
            files: [adminAttachment],
          });
        } catch (error) {
          console.log(`Could not DM admin ${admin.user.tag}`);
        }
      }

      if (ticketCreator) {
        try {
          const creatorEmbed = new EmbedBuilder()
            .setColor(0xED4245)
            .setTitle(`⚠️ Your Ticket Was Force Closed`)
            .setDescription(
              `Your ticket **#${ticketData.ticket_id}** has been force closed.\n\n` +
              `**Reason:** ${reason}\n` +
              `**Action Taken:** You have been muted for 1 day\n\n` +
              `Please follow the server rules in future tickets.`
            );

          const creatorAttachment = new AttachmentBuilder(Buffer.from(html, "utf-8"), {
            name: `ticket-${ticketData.ticket_id}-forceclose-transcript.html`,
          });

          await ticketCreator.send({
            embeds: [creatorEmbed],
            files: [creatorAttachment],
          });
        } catch (error) {
          console.log("Could not DM ticket creator");
        }
      }

      if (panel.transcriptChannel) {
        const transcriptChannel = message.guild.channels.cache.get(panel.transcriptChannel);
        if (transcriptChannel) {
          const transcriptAttachment = new AttachmentBuilder(buffer, {
            name: `ticket-${ticketData.ticket_id}-forceclose-transcript.html`,
          });

          await transcriptChannel.send({
            embeds: [forceCloseEmbed],
            files: [transcriptAttachment],
          });
        }
      }

      db.closeTicket(message.channel.id, message.author.id);
      db.deleteTicket(message.channel.id);

      const finalEmbed = new EmbedBuilder()
        .setColor(0xED4245)
        .setTitle(`⚠️ Ticket Force Closed`)
        .setDescription(
          `**Force Closed By:** ${message.author}\n` +
          `**Reason:** ${reason}\n` +
          `**User Muted:** ${ticketCreator ? 'Yes (1 day)' : 'No (user not found)'}\n\n` +
          `Transcripts sent to:\n` +
          `├─ Server Owner\n` +
          `├─ All Admins\n` +
          `├─ Ticket Creator\n` +
          `${panel.transcriptChannel ? `└─ <#${panel.transcriptChannel}>` : '└─ No transcript channel set'}\n\n` +
          `This channel will be deleted in **10 seconds**.`
        );

      await loadingMsg.edit({ embeds: [finalEmbed] });

      setTimeout(async () => {
        try {
          await message.channel.delete();
        } catch (error) {
          console.error("Channel deletion error:", error);
        }
      }, 10000);

    } catch (error) {
      console.error("Force close ticket error:", error);
      
      const errorEmbed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} Force Close Failed`)
        .setDescription(`Failed to force close ticket: ${error.message}`);

      await loadingMsg.edit({ embeds: [errorEmbed] });
    }
  },
};
