import {
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  PermissionFlagsBits,
  AttachmentBuilder,
} from "discord.js";
import { db } from "#database/DatabaseManager";
import emoji from "#config/emoji";

async function generateHTMLTranscript(channel, ticketData, panel, client) {
  const messages = await channel.messages.fetch({ limit: 100 });
  const sortedMessages = messages.sort((a, b) => a.createdTimestamp - b.createdTimestamp);

  const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ticket #${ticketData.ticket_id} Transcript</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: #36393f; color: #dcddde; padding: 20px; }
    .header { background: #2f3136; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .header h1 { color: #fff; font-size: 24px; margin-bottom: 10px; }
    .header p { color: #b9bbbe; font-size: 14px; }
    .messages { background: #36393f; }
    .message { display: flex; padding: 8px 16px; }
    .message:hover { background: #32353b; }
    .avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 16px; background: #5865f2; display: flex; align-items: center; justify-content: center; color: #fff; font-weight: bold; }
    .content { flex: 1; }
    .author { font-weight: 600; color: #fff; margin-right: 8px; }
    .timestamp { color: #72767d; font-size: 12px; }
    .text { margin-top: 4px; line-height: 1.4; word-wrap: break-word; }
    .attachment { margin-top: 8px; padding: 10px; background: #2f3136; border-radius: 4px; }
    .attachment a { color: #00aff4; text-decoration: none; }
    .footer { margin-top: 20px; padding: 20px; background: #2f3136; border-radius: 8px; text-align: center; color: #72767d; font-size: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Ticket #${ticketData.ticket_id} - ${ticketData.category || "General"}</h1>
    <p>Created by User ID: ${ticketData.user_id}</p>
    <p>Transcript generated on ${new Date().toLocaleString()}</p>
  </div>
  <div class="messages">
    ${sortedMessages.map(msg => `
      <div class="message">
        <div class="avatar">${msg.author.username.charAt(0).toUpperCase()}</div>
        <div class="content">
          <span class="author">${msg.author.tag}</span>
          <span class="timestamp">${msg.createdAt.toLocaleString()}</span>
          <div class="text">${msg.content || ""}</div>
          ${msg.attachments.size > 0 ? `
            <div class="attachment">
              ${msg.attachments.map(att => `<a href="${att.url}" target="_blank">${att.name}</a>`).join("<br>")}
            </div>
          ` : ""}
        </div>
      </div>
    `).join("")}
  </div>
  <div class="footer">
    <p>Total Messages: ${sortedMessages.size}</p>
    <p>Generated by ${client.user.username}</p>
  </div>
</body>
</html>`;

  return html;
}

export default {
  name: "close",
  description: "Close the current ticket (generates transcript, does not delete channel)",
  usage: "close [reason]",
  aliases: ["closeticket"],
  category: "Ticket",
  cooldown: 3,

  async execute({ client, message, args }) {
    const ticketData = db.getTicket(message.channel.id);

    if (!ticketData) {
      const embed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} Not a Ticket`)
        .setDescription("This command can only be used in a ticket channel.");

      return message.reply({ embeds: [embed] });
    }

    const panel = db.getTicketPanel(message.guild.id, ticketData.panel_id);

    if (!panel) {
      const embed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} Panel Not Found`)
        .setDescription("The ticket panel configuration was not found.");

      return message.reply({ embeds: [embed] });
    }

    const hasPermission =
      message.member.permissions.has(PermissionFlagsBits.ManageChannels) ||
      panel.supportRoles.some((roleId) =>
        message.member.roles.cache.has(roleId)
      ) ||
      message.author.id === ticketData.user_id;

    if (!hasPermission) {
      const embed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} No Permission`)
        .setDescription("You don't have permission to close this ticket.");

      return message.reply({ embeds: [embed] });
    }

    const reason = args.join(" ") || "No reason provided";

    const loadingEmbed = new EmbedBuilder()
      .setColor(0x000000)
      .setTitle(`${emoji.get("loading")} Closing Ticket...`)
      .setDescription("Generating transcript and closing ticket...");

    const loadingMsg = await message.channel.send({ embeds: [loadingEmbed] });

    try {
      const alreadySentTranscript = db.isTranscriptSent(message.channel.id);
      
      if (!alreadySentTranscript && panel.transcriptChannel) {
        const html = await generateHTMLTranscript(message.channel, ticketData, panel, client);
        const buffer = Buffer.from(html, "utf-8");
        const attachment = new AttachmentBuilder(buffer, {
          name: `ticket-${ticketData.ticket_id}-transcript.html`,
        });

        const transcriptChannel = message.guild.channels.cache.get(panel.transcriptChannel);
        if (transcriptChannel) {
          const transcriptEmbed = new EmbedBuilder()
            .setColor(0x000000)
            .setTitle(`${emoji.get("ticketTranscript")} Ticket Transcript`)
            .setDescription(
              `**Ticket:** #${ticketData.ticket_id}\n` +
              `**Category:** ${ticketData.category || "General"}\n` +
              `**Created By:** <@${ticketData.user_id}>\n` +
              `**Closed By:** ${message.author}\n` +
              `**Reason:** ${reason}\n` +
              `**Closed At:** <t:${Math.floor(Date.now() / 1000)}:F>`
            );

          await transcriptChannel.send({
            embeds: [transcriptEmbed],
            files: [attachment],
          });
          
          db.markTranscriptSent(message.channel.id);
        }
      }

      db.closeTicket(message.channel.id, message.author.id);

      if (panel.categoryClosed) {
        try {
          await message.channel.setParent(panel.categoryClosed);
        } catch (error) {
          console.error("Failed to move ticket to closed category:", error);
        }
      }

      try {
        await message.channel.permissionOverwrites.edit(ticketData.user_id, {
          SendMessages: false,
        });
      } catch (error) {
        console.error("Failed to update permissions:", error);
      }

      const closedEmbed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("ticketClose")} Ticket Closed`)
        .setDescription(
          `**Closed By:** ${message.author}\n` +
          `**Reason:** ${reason}\n\n` +
          `Transcript has been saved${panel.transcriptChannel ? ` to <#${panel.transcriptChannel}>` : ""}.\n` +
          `Use \`delete\` command to permanently delete this ticket.`
        );

      await loadingMsg.edit({ embeds: [closedEmbed] });

      const alreadySentReview = db.isReviewSent(message.channel.id);
      
      if (!alreadySentReview) {
        try {
          const user = await client.users.fetch(ticketData.user_id);

          const reviewEmbed = new EmbedBuilder()
            .setColor(0x000000)
            .setTitle(`${emoji.get("ticketStar")} Rate Your Support Experience`)
            .setDescription(
              `Your ticket **#${ticketData.ticket_id}** in **${ticketData.category || "General"}** has been closed.\n\n` +
              `How would you rate your support experience?\n\n` +
              `Would you like to leave a review comment?`
            );

          const ratingRow = new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId(`ticket_rate_${message.channel.id}_1`)
              .setLabel("1")
              .setEmoji("⭐")
              .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
              .setCustomId(`ticket_rate_${message.channel.id}_2`)
              .setLabel("2")
              .setEmoji("⭐")
              .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
              .setCustomId(`ticket_rate_${message.channel.id}_3`)
              .setLabel("3")
              .setEmoji("⭐")
              .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
              .setCustomId(`ticket_rate_${message.channel.id}_4`)
              .setLabel("4")
              .setEmoji("⭐")
              .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
              .setCustomId(`ticket_rate_${message.channel.id}_5`)
              .setLabel("5")
              .setEmoji("⭐")
              .setStyle(ButtonStyle.Primary)
          );

          const reviewActionRow = new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId(`ticket_review_yes_${message.channel.id}`)
              .setLabel("Yes, leave a comment")
              .setStyle(ButtonStyle.Success),
            new ButtonBuilder()
              .setCustomId(`ticket_review_no_${message.channel.id}`)
              .setLabel("No, skip")
              .setStyle(ButtonStyle.Secondary)
          );

          await user
            .send({
              embeds: [reviewEmbed],
              components: [ratingRow, reviewActionRow],
            })
            .then(() => {
              db.markReviewSent(message.channel.id);
            })
            .catch(() => {
              console.log(`Could not DM user ${user.tag} for review`);
            });
        } catch (error) {
          console.error("Review DM error:", error);
        }
      }

    } catch (error) {
      console.error("Close ticket error:", error);
      
      const errorEmbed = new EmbedBuilder()
        .setColor(0x000000)
        .setTitle(`${emoji.get("cross")} Close Failed`)
        .setDescription(`Failed to close ticket: ${error.message}`);

      await loadingMsg.edit({ embeds: [errorEmbed] });
    }
  },
};
